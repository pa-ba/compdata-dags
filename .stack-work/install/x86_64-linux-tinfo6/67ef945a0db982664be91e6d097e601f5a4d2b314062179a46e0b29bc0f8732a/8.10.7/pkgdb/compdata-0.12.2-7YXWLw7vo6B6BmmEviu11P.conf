name:                 compdata
version:              0.12.2
visibility:           public
id:                   compdata-0.12.2-7YXWLw7vo6B6BmmEviu11P
key:                  compdata-0.12.2-7YXWLw7vo6B6BmmEviu11P
license:              BSD-3-Clause
maintainer:           paba@itu.dk
author:               Patrick Bahr, Tom Hvitved
synopsis:             Compositional Data Types
description:
    This library implements the ideas of /Data types a la carte/
    (Journal of Functional Programming, 18(4):423-436, 2008,
    <http://dx.doi.org/10.1017/S0956796808006758>) as outlined in the
    paper /Compositional data types/ (Workshop on Generic Programming,
    83-94, 2011, <http://dx.doi.org/10.1145/2036918.2036930>). The
    purpose of this library is to allow the programmer to construct data
    types -- as well as the functions defined on them -- in a modular
    fashion. The underlying idea is to separate the signature of a data
    type from the fixed point construction that produces its recursive
    structure. Signatures can then be composed and decomposed freely.

    Building on that foundation, this library provides additional
    extensions and (run-time) optimisations which make compositional data types
    usable for practical implementations. In particular, it
    provides an excellent framework for manipulating and analysing
    abstract syntax trees in a type-safe manner. Thus, it is perfectly
    suited for programming language implementations, especially, in an environment
    consisting of a family of tightly interwoven /domain-specific languages/.

    In concrete terms, this library provides the following features:

    *  Compositional data types in the style of Wouter Swierstra's
    Functional Pearl /Data types a la carte/. The implementation of
    signature subsumption is based on the paper
    /Composing and Decomposing Data Types/ (Workshop on Generic
    Programming, 2014, to appear), which makes signature composition more
    flexible.

    *  Modular definition of functions on compositional data types through
    catamorphisms and anamorphisms as well as more structured
    recursion schemes such as primitive recursion  and co-recursion,
    and course-of-value iteration and co-iteration.

    *  Support for monadic computations via monadic variants of all
    recursion schemes.

    *  Support of a succinct programming style over compositional data types
    via generic programming combinators that allow various forms of
    generic transformations and generic queries.

    *  Generalisation of compositional data types (terms) to
    compositional data types \"with holes\" (contexts). This allows
    flexible reuse of a wide variety of catamorphisms (called
    /term homomorphisms/) as well as an efficient composition of them.

    *  Operations on signatures, for example, to add and remove
    annotations of abstract syntax trees. This includes combinators to
    propagate annotations fully automatically through certain
    term homomorphisms.

    *  Optimisation of the implementation of recursion schemes. This
    includes /short-cut fusion/ style optimisation rules which yield a
    performance boost of up to factor six.

    *  Automatic derivation of instances of all relevant type classes for
    using compositional data types via /Template Haskell/. This includes
    instances of 'Prelude.Eq', 'Prelude.Ord' and 'Prelude.Show' that are
    derived via instances for functorial variants of them. Additionally,
    also /smart constructors/, which allow to easily construct inhabitants
    of compositional data types, are automatically generated.

    *  /Mutually recursive data types/ and
    /generalised algebraic data types (GADTs)/. All of the above is also lifted
    to families of mutually recursive data types and (more generally) GADTs.
    This extension resides in the module "Data.Comp.Multi".

    Examples of using (generalised) compositional data types are bundled
    with the package in the folder @examples@.

    There are some supplementary packages, some of which were included
    in previous versions of this package:

    * @compdata-param@
    <https://hackage.haskell.org/package/compdata-param>: a parametric
    variant of compositional data types to deal with variable binders
    in a systematic way.

    * @compdata-automata@
    <https://hackage.haskell.org/package/compdata-automata>: advanced
    recursion schemes derived from tree automata that allow for a
    higher degree of modularity and make it possible to apply fusion.

    * @compdata-dags@
    <https://hackage.haskell.org/package/compdata-dags>: recursion
    schemes on directed acyclic graphs.

category:             Generics
abi:                  ea0d61633969dff5bce7dc9e442ab666
exposed:              True
exposed-modules:
    Data.Comp Data.Comp.Algebra Data.Comp.Annotation
    Data.Comp.Arbitrary Data.Comp.Decompose Data.Comp.DeepSeq
    Data.Comp.Derive Data.Comp.Derive.Utils Data.Comp.Desugar
    Data.Comp.Equality Data.Comp.Generic Data.Comp.Mapping
    Data.Comp.Matching Data.Comp.Multi Data.Comp.Multi.Algebra
    Data.Comp.Multi.Annotation Data.Comp.Multi.Derive
    Data.Comp.Multi.Desugar Data.Comp.Multi.Equality
    Data.Comp.Multi.Generic Data.Comp.Multi.HFoldable
    Data.Comp.Multi.HFunctor Data.Comp.Multi.HTraversable
    Data.Comp.Multi.LowerOrder Data.Comp.Multi.Mapping
    Data.Comp.Multi.Multi.Projection Data.Comp.Multi.Ops
    Data.Comp.Multi.Ordering Data.Comp.Multi.Projection
    Data.Comp.Multi.Show Data.Comp.Multi.Sum Data.Comp.Multi.Term
    Data.Comp.Multi.Variables Data.Comp.Ops Data.Comp.Ordering
    Data.Comp.Projection Data.Comp.Render Data.Comp.Show Data.Comp.Sum
    Data.Comp.Term Data.Comp.TermRewriting Data.Comp.Thunk
    Data.Comp.Unification Data.Comp.Variables

hidden-modules:
    Data.Comp.SubsumeCommon Data.Comp.Derive.Equality
    Data.Comp.Derive.Ordering Data.Comp.Derive.Arbitrary
    Data.Comp.Derive.Show Data.Comp.Derive.DeepSeq
    Data.Comp.Derive.SmartConstructors
    Data.Comp.Derive.SmartAConstructors Data.Comp.Derive.Foldable
    Data.Comp.Derive.Traversable Data.Comp.Derive.HaskellStrict
    Data.Comp.Derive.Compat Data.Comp.Multi.Derive.HFunctor
    Data.Comp.Multi.Derive.HFoldable
    Data.Comp.Multi.Derive.HTraversable Data.Comp.Multi.Derive.Equality
    Data.Comp.Multi.Derive.Ordering Data.Comp.Multi.Derive.Show
    Data.Comp.Multi.Derive.SmartConstructors
    Data.Comp.Multi.Derive.SmartAConstructors

import-dirs:
    /home/manifold1/Software/compdata-dags/.stack-work/install/x86_64-linux-tinfo6/67ef945a0db982664be91e6d097e601f5a4d2b314062179a46e0b29bc0f8732a/8.10.7/lib/x86_64-linux-ghc-8.10.7/compdata-0.12.2-7YXWLw7vo6B6BmmEviu11P

library-dirs:
    /home/manifold1/Software/compdata-dags/.stack-work/install/x86_64-linux-tinfo6/67ef945a0db982664be91e6d097e601f5a4d2b314062179a46e0b29bc0f8732a/8.10.7/lib/x86_64-linux-ghc-8.10.7/compdata-0.12.2-7YXWLw7vo6B6BmmEviu11P

dynamic-library-dirs:
    /home/manifold1/Software/compdata-dags/.stack-work/install/x86_64-linux-tinfo6/67ef945a0db982664be91e6d097e601f5a4d2b314062179a46e0b29bc0f8732a/8.10.7/lib/x86_64-linux-ghc-8.10.7

data-dir:
    /home/manifold1/Software/compdata-dags/.stack-work/install/x86_64-linux-tinfo6/67ef945a0db982664be91e6d097e601f5a4d2b314062179a46e0b29bc0f8732a/8.10.7/share/x86_64-linux-ghc-8.10.7/compdata-0.12.2

hs-libraries:         HScompdata-0.12.2-7YXWLw7vo6B6BmmEviu11P
depends:
    QuickCheck-2.14.2-9znbJPXXIAU5zq9aq8lWOx base-4.14.3.0
    containers-0.6.5.1 deepseq-1.4.4.0
    dependent-sum-0.7.1.0-Kzb37pWk6RKFe4ngAjRqYH mtl-2.2.2
    template-haskell-2.16.0.0
    th-expand-syns-0.4.8.0-CappYi20WeADd9Wa2yzCzM transformers-0.5.6.2
    tree-view-0.5.1-BiraaYGE8RhIxCXxwQIJvi

haddock-interfaces:
    /home/manifold1/Software/compdata-dags/.stack-work/install/x86_64-linux-tinfo6/67ef945a0db982664be91e6d097e601f5a4d2b314062179a46e0b29bc0f8732a/8.10.7/doc/compdata-0.12.2/compdata.haddock

haddock-html:
    /home/manifold1/Software/compdata-dags/.stack-work/install/x86_64-linux-tinfo6/67ef945a0db982664be91e6d097e601f5a4d2b314062179a46e0b29bc0f8732a/8.10.7/doc/compdata-0.12.2
